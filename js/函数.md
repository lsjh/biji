## 定义一个函数

函数要先定义后使用

```js
let a=function(){
    alert(1)
}
a();

function a(){
    
}
a();
//这样定义的函数会在解析代码的时候最先执行。a()可以放在函数前面。通过let 或者var 定义的函数不会提前调用。
//都是放在后面调用的话两种方式都是等价的，只是前者不允许提前调用，不推荐提前调用。
```

```js
let a=function b() {
    alert(2);
    console.log(b);
}
b();
//一旦定义了函数，函数的名称就没作用了，在外面调用函数，函数不起作用，会报错.
a();
//函数的内部可以通过b来找到函数的本身。此时b===a;
```

**一般不会出现这样定义函数的方式，不会两个名字同时出现**

## 函数表达式

函数表达式可以直接加括号执行

```js
function a() {
    alert(3);
}
a();
//使用这种形式定义的函数，不能直接加括号执行，只能通过名字加括号执行；
let a=function(){
    alert(a);
}();
//这样方式定义的函数，可以直接在后面加括号执行
```

函数表达式的另外几种情况

```js
(function(){
    alert(2);
})()
//用括号把一个函数括起来，整体就是一个函数表达式

(function(){
    alert(3);
}());
+function(){
    alert(6);
}();
-function() {
    alert(7);
}();
~function(){
    alert(8);
}();
!function(){
    alert(9);
}();
一般情况下使用前两种，不会改变函数的返回值。使用最多的是第一种
```

## 参数

 形参

实参 可以是任何数，也可以是函数

定义函数的时候，()里面是允许写变量名字的，这么变量名字就是形参，形参只针对函数内部起作用。

```js 
function a(x,y){
    alert(x+y);
}
a(2,4);
函数使用的时候，()里面写的是实参；
```

不定参

每个函数在内部都有不定参，arguments;是一个类数组，存储着所有实参

```js
function sum(){
    console.log(arguments);
}
sum(1,2);
sum(3,5,6,7);
```

练习：利用arguments求和

```js
function sum(){
    let s=0;
    for(let i=0,len=arguments.length;i<len;i++){
        s+=arguments[i];
    }
    console.log(s);
}
sum(2,4,5,5);
```

### 递归   10层后会报错

在函数的内部执行自己叫做递归

```js
function a() {
    a();
}
a() //要让a停下来
```

例子：求阶乘

```js
function a(num){
    if(num===1){
        return 1;
    }
    return {num*a(num-1)};
}
alert(a(5))
```

### this

对象方法自执行，this指向对象本身

```js
let afei={
    name:"a",
    x:function(){
        console.log(this);
    }
};
afei.x();//对象方法自执行，this指向对象   afei.x.a()这种的,this指向.之前的;找他爸爸；就近原则
```

## return

每个函数都有一个返回值，return，return后面的代码不会执行,return可以没有东西接收

函数默认返回undefined;如果要返回别的 return 返回的值

return可有可无，根据需求

```js
function a(){
   alert(2);
   alert(3);
   return 222;
 }
 let x= a();
 console.log(x);
```

当某种条件满足才去执行，可以写成条件不满足return

```js
if(goudan===i) return;
```

```js
function a(){
    return function(){
        alert(4)
    }
}
document.onclick=a();
```



## 作用域以及解析顺序

作用域是代码起作用的范围

### ES5

在es5里，用var 和function 定义变量，作用域是往上离变量最近的函数

script标签是最大的作用域，我们称之为全局作用域

如果var/function在全局作用域里定义了变量的话，相等于给window添加了一个属性

```js
function a(){
    var g=10;
    console.log(g);
}
console.log(window.a);


var b=10;
console.log(window.b)
```

任意作用域里面，如果不加var直接产生了没有定义过的变量，那么这个变量相当于全局变量,但是实际开发不允许这样写

```js
function a(){
    b=10;
}
a();
console.log(b);
```

```js
function a(){
    var x=y=5;
}
a();
console.log(y);
console.log(X);
```

作用域链:自己有就用自己的，自己没有就找上一级的，上级没有的情况下，取值会报错，赋值的话如果不是严格模式相当于给window加了一个属性，严格模式会报错。

```js
var x=10;
function a(){
    var y=5;
    return x+y;
}
console.log(a())
```

